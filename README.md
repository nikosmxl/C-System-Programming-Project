Τροπος μεταγλωτισσης: make
Τροπος εκτελεσης: ./mysh
Τροπος τερματισμου: quit

Υλοποιησεις: Ολα τα ερωτηματα

Σχετικες αλλαγες στον τροπο εισαγωγης εντολων:
    Οι εντολες μπορουν να εχουν στο τελος &; ή & ή ; αλλα δεν μπορει μετα απο αυτα να ξεκιναει αλλη εντολη χωρις κενο ενδιαμεσα (π.χ. Το ./count1&;./count2&; θα πρεπει να εχει κενο ενδιαμεσα για να δουλεψει).

Επεξηγηση δομης minicommand:
    Εχω φτιαξει ενα struct το οποιο κραταει πληροφοριες για ενα minicommand. Ως minicommand οριζω οποιαδηποτε εντολη εχει ανεξαρτητη εκτελεση απο μια αλλη στην ιδια γραμμη του χρηστη.
    Π.χ. cat redirection.h | sort | tail -3 > file.txt αποτελειται απο 3 minicommands (cat, sort, tail).
    Π.χ. ls; pwd; cat file.txt; echo hello; αποτελειται απο 4 minicommands (ls, pwd, cat, echo).
    Ενα minicommand αποτελειται απο boolean μεταβλητες που δινουν πληροφοριες (οπως αν εχει redirection, pipe, αν ειναι background κλπ.), απο το string command, τους πινακες απο strings με τα arguments του command, ή τα arguments των redirections.

Τροπος λειτουργειας του προγραμματος:
    Το προγραμμα λειτουργει με καποιες σταθερες (#define) οι οποιες μπορουν να αλλαχθουν αν χρειαστει. Κυριο ρολο παιζει η δομη minicommand. Ενας πινακας απο minicommands κραταει ολα τα ανεξαρτητα εκτελεσιμα commands ετσι ωστε να τα εκτελεσει οταν τελειωσει το διαβασμα απο το input. Μετα το διαβασμα του input, αναλογα τα δεδομενα που εχει το καθε minicommand, το εκτελει καταλληλα. Πριν χωρισει το input σε λεξεις (strtok) ελεγχει για εντολη myHistory ή καποιο alias. Τα errors του προγραμματος προσπαθησα να τα κανω οσο πιο κοντα στα errors του bash οπου μπορεσα το ιδιο και στο πως τα χειριζεται.

Redirections:
- Σε περιπτωση πολλων αρχειων γινεται redirection μονο στο/απο τελευταιο. Τα υπολοιπα απλα ανοιγονται και κλεινονται για γινουν οι αντιστοιχοι ελεγχοι και λειτουργιες που γινονται στο bash (στο redirection in ελεγχεται αν υπαρχει, στο redirection out το δημιουργει αν δεν υπαρχει ή το κανει trunc αν εχει ζητηθει.)
- Σε περιπτωση wildcards, αν δε βρεθει αρχειο, εκτυπωνεται αντιστοιχο μηνυμα. Αν βρεθει ενα μοναδικο αρχειο, εκτελειται η εντολη. Αν βρεθουν πανω απο ενα, εκτυπωνεται error.

Pipes:
- Τα pipes λειτουργουν με εναν πινακα απο pipes. Αν το προηγουμενη minicommand εχει pipe_output τοτε το επομενο θα εχει pipe_input και θα διαβασει απο εκει που εγραψε το προηγουμενο.

Wildcards (*/?): 
- Λειτουργουν με την βοηθεια της myglob (η οποια χρησιμοποιει την glob) και εισαγει τα ονοματα των αρχειων που βρεθηκαν στον πινακα που της δοθηκε. Αν καλειται απο redirection ελεγχεται κι αν το πληθος ειναι μεγαλυτερο του ενος για αντιστοιχο error. Επιστρεφει θετικο αριθμο σε επιτυχια (το πληθος των αρχειων που βρεθηκαν), αρνητικο σε αποτυχια.

Background processes:
- Κι αυτη την πληροφορια την παιρνω απο το minicommand struct το οποιο κραταει αν καθε minicommand ειναι bg ή οχι. Αν ειναι, τοτε το Ctrl+C και Ctrl+Z διαχειριζονται οπως και στο shell (με την εκτυπωση ενος μηνυματος και αγνοηση του σηματος) και επισης το shell δεν περιμενει στην wait για τον τερματισμο του process (WNOHANG).

Signal Handling:
- Το shell αγνοει το SIGINT και το SIGTSTP και αντι αυτων εκτυπωνει ενα μηνυμα οτι πατηθηκε Ctrl-C/Ctrl-Z αντιστοιχα. Οι διεργασιες παιδια που ειναι foreground ακουνε στα σηματα. Τα background δεν επιρεαζονται οπως και το shell και απλα εκτυπωνουν μηνυμα.

Aliases:
- Τα aliases εκτελουνται κανονικα. Δημιουργουνται και διαγραφονται με τη βοηθεια των συναρτησεων create_alias/destroy_alias. Κρατιουνται σε εναν πινακα απο δομες alias. 

myHistory:
- Η εντολη myHistory εμφανιζει τις τελευταιες 20 εντολες (μπορει να αλλαχθει ο αριθμος στα defines). Την εντολη myHistory <αριθμος> την αλλαξα γιατι μου φαινοταν πιο ωραιο ετσι οπως το εκανα. Αντι αυτου οταν παταει ο χρηστης myHistory κατω απο τις εντολες μπορει να πληκτρολογησει εναν αριθμο απο το 1 ως το 20 ή exit σε περιπτωση που δεν θελει να εκτελεσει καποια απο αυτες.
- Λειτουργει με τη βοηθεια της search_history()
